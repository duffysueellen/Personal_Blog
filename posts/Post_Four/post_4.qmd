---
title: "Network Block Modeling2"
author: "Sue-Ellen Duffy"
date: "2024-04-25"
categories: [code, analysis, block_model]
---

```{r}
#| label: setup
#| warning: false
#| message: false

library(tidyverse)
library(readr)
library(igraph)
library(sna)
library(intergraph)


library(ggplot2)
library(patchwork)
```

This post will explore the Synthetic Mass network data in more detail.

# Read in Data
```{r}
#| warning: false
#| message: false
pat_attr <- read_csv("post_one_data/pat_attr.csv", 
    col_types = cols(...1 = col_skip()))
pro_attr <- read_csv("post_one_data/pro_attr.csv", 
    col_types = cols(...1 = col_skip()))
encounters_cleaning <- read_csv("post_one_data//encounters_cleaning.csv", 
    col_types = cols(...1 = col_skip()))
encounter_attributes <- read_csv("post_one_data/encounter_attributes.csv", 
    col_types = cols(...1 = col_skip()))
encounters_el  <- read_csv("post_one_data/encounters_el.csv", 
    col_types = cols(...1 = col_skip()))
encounters_st_3 <- read_csv("post_one_data/encounters.st.3.csv", 
    col_types = cols(...1 = col_skip()))
attribute_list <- read.csv("post_one_data/attribute_list.csv")
```
# Prep Data for Analysis
```{r}
#combine pro and pat attr
pat_attr$type <- "PATIENT"
pro_attr$type <- "PROVIDER"
both_attr <- bind_rows(pat_attr, pro_attr)
head(both_attr)
```

# Create bipartite network with attributes
```{r}
encounters.stat <- network(encounters_el,
                         directed = FALSE,
                         bipartite = TRUE,
                         matrix.type = "edgelist",
                         vertex.attr = attribute_list)
```

```{r}
#create igraph
encounters.ig <- graph_from_biadjacency_matrix(encounters.stat)
```

```{r}
encounters.stat2 <- asNetwork(encounters.ig)
```

```{r}
projected_graph <- bipartite_projection(encounters.ig)
provider_matrix <- as.matrix(as_adjacency_matrix(projected_graph$proj2))

provider.stat <- asNetwork(projected_graph$proj2)

provider.se <- equiv.clust(provider_matrix,
 equiv.fun = "sedist",
 method = "hamming",
 mode = "graph",
 cluster.method = "complete")

names(provider.se)
```
```{r}
plot(provider.se, main = "provider")
rect.hclust(provider.se$cluster, k = 12)
```

```{r}
blk_model.provider.org <- blockmodel(provider_matrix,
 provider.se, k = 6)
```

```{r}
 blk_model.provider.org$block.model
```
```{r}
plot.block<-function(x=blk_mod, main=NULL, cex.lab=.00001,show_labels = FALSE){
 plot.sociomatrix(x$blocked.data, labels=list(x$plabels,x$plabels),
 main=main, drawlines = FALSE, cex.lab=cex.lab)
 for (j in 2:length(x$plabels)) if (x$block.membership[j] !=
 x$block.membership[j-1])
 abline(v = j- 0.5, h = j- 0.5, lty = 3, xpd=FALSE)
 }
 
plot.block(blk_model.provider.org, main = "provider")
```

```{r}
# Load the igraph package
library(igraph)

# Create an igraph object from the blockmodel
g <- graph_from_adjacency_matrix(projected_graph$provider, mode = "directed", weighted = FALSE)

# Plot the graph without labels
plot(g, layout = layout.fruchterman.reingold, vertex.label = NA, vertex.size = 100, edge.width = 1)
```


```{r}
#blks <- blockmodeling::optRandomParC(provider_matrix, k=6, rep=10, approaches="ss", blocks="com")
```

```{r}
# Save the blks object to a file
#saveRDS(blks, "blks_results.rds")

# Later, when you want to use it again, you can read it back into R
blks <- readRDS("blks_results.rds")
```
```{r}
# blockmodel with optimized partition
blk_mod <- blockmodel(provider_matrix, blks$best$best1$clu,
                      plabels = rownames(provider_matrix))
# print blockmodel object
blk_mod$block.model
```


```{r}
plot.block(blk_mod, main = "Provider 6 Block Model",
           cex.lab = .000001)
```

```{r}
#assign block membership to vertex attribute
provider.stat%v%"role"<-blk_mod$block.membership[match(provider.stat%v%"vertex.names",blk_mod$plabels)]
#plot network using "role" to color nodes
GGally::ggnet2(provider.stat,
               node.color="role", 
               node.size=sna::degree(provider.stat, gmode="graph"),
               node.alpha = .5)  + ggtitle("Provider 6 Block Model Network")
```


```{r}
#blks2 <- blockmodeling::optRandomParC(provider_matrix, k=12, rep=10, approaches="ss", blocks="com")
```
```{r}
# Save the blks2 object to a file
#saveRDS(blks2, "blks2_results.rds")

# Later, when you want to use it again, you can read it back into R
blks2 <- readRDS("blks2_results.rds")
```

```{r}
# blockmodel with optimized partition
blks2_mod <- blockmodel(provider_matrix, blks2$best$best1$clu,
                      plabels = rownames(provider_matrix))
# print blockmodel object
blks2_mod$block.model
```


```{r}
plot.block(blks2_mod, main = "Provider 12 Block Model",
           cex.lab = .000001)
```

```{r}
#assign block membership to vertex attribute
provider.stat%v%"role2"<-blks2_mod$block.membership[match(provider.stat%v%"vertex.names",blks2_mod$plabels)]
#plot network using "role" to color nodes
GGally::ggnet2(provider.stat,
               node.color="role2", 
               node.size=sna::degree(provider.stat, gmode="graph"),
               node.alpha = .5) + ggtitle("Provider 12 Block Model Network")
```
With 12 distinct blocks, I start to loose definition of the exterior and interior. Notice the green color mixed in close to the center and tied with gray nodes in the outer ring. This is too many blocks, 6 defines more visually appealing divisions. Additional analysis will need to be done to understand if these blocks can actually be defined by anything other than ties. Onto deeper exploration of blocks...


#Next Steps Jaccard similarity
```{r}
library(ade4)
```

```{r}
encounters.adj.ig <- igraph::as_biadjacency_matrix(encounters.ig)

patients_jaccard <- dist.binary(encounters.adj.ig,
            method = 1, # method=1 Jaccard index
            upper = TRUE,
            diag = FALSE)

providers_jaccard <- dist.binary(t(encounters.adj.ig), #transpose matrix
            method = 1,
            upper = TRUE,
            diag = FALSE)

patients_jaccard <- as.matrix(patients_jaccard)
diag(patients_jaccard) <- 0

```

```{r}
#binarize
patients_jaccard_bi <- ifelse(patients_jaccard > 0.99, 1, 0)
```

```{r}
#create igraph object
patients_jaccard.ig <- graph_from_adjacency_matrix(patients_jaccard_bi, mode = "undirected")
patients_jaccard.ig
```
```{r}
plot(patients_jaccard.ig,  edge.width = 0.0002, edge.color = "lightgray",  vertex.size = 2, vertex.label = NA)
```




