---
title: "POST 10"
subtitle: "Gender Matrix"
author: "Sue-Ellen Duffy"
date: "2024-05-05"
categories: [code, analysis, block_model]
---

```{r}
#| label: setup
#| warning: false
#| message: false

library(tidyverse)
library(readr)
library(igraph)
library(sna)
library(intergraph)
library(statnet)
library(ggplot2)
library(sf)
library(tidyverse)
library(tmap)
library(tigris)
library(stplanr)
```

This post will explore the a Gender Matrix

# Read in Data

```{r}
#| warning: false
#| message: false
pat_attr <- read_csv("post5drug_data/pat_attr.csv", 
    col_types = cols(...1 = col_skip()))
pro_attr <- read_csv("post5drug_data/pro_attr.csv", 
    col_types = cols(...1 = col_skip()))
encounters_cleaning <- read_csv("post5drug_data//encounters_cleaning.csv", 
    col_types = cols(...1 = col_skip()))
encounters_cleaned <- read_csv("post5drug_data//encounters_cleaned.csv", 
    col_types = cols(...1 = col_skip()))
encounter_attributes <- read_csv("post5drug_data/encounter_attributes.csv", 
    col_types = cols(...1 = col_skip()))
encounters_el  <- read_csv("post5drug_data/encounters_el.csv", 
    col_types = cols(...1 = col_skip()))
encounters_st_3 <- read_csv("post5drug_data/encounters.st.3.csv", 
    col_types = cols(...1 = col_skip()))
attribute_list <- read.csv("post5drug_data/attribute_list.csv")
pat_blks6 <- readRDS("pat_blks6_results.rds")
prov_blks6 <- readRDS("prov_blks6_results.rds")
```

# Create Gender Matrix

```{r}
#create edgelist
# Sample dataframe

# Function to calculate gender sameness
calculate_gender_sameness <- function(gender1, gender2) {
  if (gender1 == "Female" && gender2 == "Female") {
    return(1)  # Female patient and female provider
  } else if (gender1 == "Male" && gender2 == "Male") {
    return(2)  # Male patient and male provider
  } else if (gender1 == "Female" && gender2 == "Male") {
    return(3)  # Female patient and male provider
  } else if (gender1 == "Male" && gender2 == "Female") {
    return(4)  # Male patient and female provider
  } else {
    return(NA) # Unknown or missing values
  }
}

# Apply function to create gender sameness column
encounter_attributes$GENDER_SAMENESS <- mapply(calculate_gender_sameness, encounter_attributes$GENDER.x, encounter_attributes$GENDER.y)

gender_sameness_df <- encounter_attributes %>%
  select(PATIENT, PROVIDER, GENDER.x, GENDER.y, GENDER_SAMENESS) %>% 
  distinct(PATIENT, PROVIDER, GENDER.x, GENDER.y, GENDER_SAMENESS)

gender_edgelist <- encounter_attributes %>% 
  select(PATIENT, PROVIDER, GENDER_SAMENESS) %>%
  distinct(PATIENT, PROVIDER, GENDER_SAMENESS)

```

Check Gender Edgelist

```{r}
head(gender_edgelist)
dim(gender_edgelist)
gender_edgelist <- data.frame(gender_edgelist)
class(gender_edgelist)
```

```{r}
g_attr_list <- (do.call(list, gender_sameness_df))
```

## Create Gender Matrix

```{r}
g.stat <- network(gender_edgelist, directed = FALSE, bipartite = TRUE, matrix.type = "edgelist", vertex.attr = g_attr_list)
# create bipartite network with attributes
gender.ig <- graph_from_biadjacency_matrix(g.stat, weight = TRUE)
```

```{r}
V(gender.ig)$shape <- ifelse(V(gender.ig)$type, "square", "circle")

# Define color palette for the GENDER_SAMENESS attribute
color_palette <- c("pink", "turquoise", "purple", "lightblue")

# Map color palette to the GENDER_SAMENESS values
edge_colors <- color_palette[g_attr_list$GENDER_SAMENESS]

vertex_colors <- ifelse(g_attr_list$GENDER.x == "Female", "pink", "turquoise")

# Plot the graph with colored edges
plot(gender.ig, layout = layout.fruchterman.reingold, 
     vertex.size = 2, 
     vertex.label.cex = 0.8, 
     vertex.color = vertex_colors,
     vertex.label = NA, 
     edge.color = edge_colors,
     edge.width = 5,
     main = "Patient Provider Incidence Graph with Gender Information")
     
     
# Define legend for vertex colors
legend("topleft",
       legend = c("FF", "MM", "FM", "MF"),  # You can customize these labels
       fill = c("pink", "turquoise", "purple", "lightblue"),   # Fill colors corresponding to vertex colors
       title = paste("Edges: Gender", "\n", "Patient:Provider"))              # Legend title

# Define legend for vertex shapes
legend("topright",
       legend = c("Patient", "Provider"),  # You can customize these labels
       pch = c(1, 0),                      # Point shapes corresponding to vertex shapes
       title = "Nodes: Who")                     # Legend title

```

The above graph does not represent the data well. There are too many inconsistencies.

```{r}
# Define the custom color palette based on the values of g_attr_list$GENDER_SAMENESS
custom_color_palette <- c( "turquoise", "purple", "gray", "pink")

# Get unique values of g_attr_list$GENDER_SAMENESS
unique_values <- unique(g_attr_list$GENDER_SAMENESS)

# Create a color mapping between unique values and custom colors
color_mapping <- setNames(custom_color_palette, unique_values)

# Map the edge colors using the color mapping
edge_colors <- sapply(g_attr_list$GENDER_SAMENESS, function(value) color_mapping[value])



# Plot the graph with edge colors
GGally::ggnet2(g.stat, 
               edge.color = edge_colors,
               edge.size = 1,
               node.size = 2,
               node.color = attribute_list$GENDER)


```

I also feel these can't be true. Looking at the way the colors change in vary scenarios between female and male nodes, these are not consistent.

```{r}
# create bipartite network with attributes
encounters.stat <- network(encounters_el,
                         directed = FALSE,
                         bipartite = TRUE,
                         matrix.type = "edgelist",
                         vertex.attr = attribute_list)
encounters.stat
```

```{r}
library(ggplot2)
library(statnet)

# Assuming g.stat and encounters.stat are network objects
# If they are adjacency matrices, you can convert them to network objects using network() function

# Calculate correlation coefficient between g.stat and encounters.stat
correlation <- cor(as.sociomatrix(g.stat), as.sociomatrix(encounters.stat))

# Convert the correlation matrix to a data frame
correlation_df <- as.data.frame(as.table(correlation))
names(correlation_df) <- c("Network1", "Network2", "Correlation")

# Create a heatmap using ggplot2
ggplot(correlation_df, aes(Network1, Network2, fill = Correlation)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  theme_minimal() +
  labs(title = "Correlation Between Network Objects",
       x = "Network 1", y = "Network 2")

```

```{r}
# Convert the network objects to adjacency matrices
adj_matrix_g_stat <- as.sociomatrix(g.stat)
adj_matrix_encounters_stat <- as.sociomatrix(encounters.stat)

# Calculate the correlation coefficient between the adjacency matrices
corr_gender_encounters <- cor(adj_matrix_g_stat, adj_matrix_encounters_stat)

# Flatten the adjacency matrices into vectors
vector_g_stat <- as.vector(adj_matrix_g_stat)
vector_encounters_stat <- as.vector(adj_matrix_encounters_stat)

# Calculate the correlation coefficient between the vectors
total_corr_gender_encounters <- cor(vector_g_stat, vector_encounters_stat)

# Print the correlation coefficient
print(total_corr_gender_encounters)
```

A correlation of 0.098 suggests a weak positive correlation, with some tendency for the matrices to move together, but the relationship is not strong.

```{r}
library(statnet)


```
